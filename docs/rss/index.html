<rss xmlns:dc=http://purl.org/dc/elements/1.1/ xmlns:content=http://purl.org/rss/1.0/modules/content/ xmlns:atom=http://www.w3.org/2005/Atom version=2.0 xmlns:media=http://search.yahoo.com/mrss/><channel><title><![CDATA[Small World]]></title><description><![CDATA[Random ideas, and attempts]]></description><link>https://codetiger.github.io/blog/</link><image><url>https://codetiger.github.io/blog/favicon.png</url><title>Small World</title><link>https://codetiger.github.io/blog/</link></image><generator>Ghost 4.39</generator><lastbuilddate>Sat, 12 Mar 2022 12:23:26 GMT</lastbuilddate><atom:link href=https://codetiger.github.io/blog/rss/ rel=self type=application/rss+xml><ttl>60</ttl><item><title><![CDATA[Building a retro style game console from scratch]]></title><description><![CDATA[Game console built from scratch using RPi Pico micro controller and 2 inch LCD display]]></description><link>https://codetiger.github.io/blog/building-a-retro-style-game-console-in-2022/</link><guid ispermalink=false>621f5a169fee2e23a8fef2c1</guid><category><![CDATA[Pico]]></category><category><![CDATA[electronics]]></category><category><![CDATA[display]]></category><category><![CDATA[GameTiger]]></category><dc:creator><![CDATA[Harishankar]]></dc:creator><pubdate>Sat, 12 Mar 2022 12:22:34 GMT</pubdate><media:content url=https://codetiger.github.io/blog/content/images/2022/03/A453673D-B98D-45DF-BA7E-D77E3AA4F09B_1_201_a-3.jpg medium=image><content:encoded><![CDATA[<img src="./..//content/images/2022/03/A453673D-B98D-45DF-BA7E-D77E3AA4F09B_1_201_a-3.jpg" alt="Building a retro style game console from scratch"><p>I have always been and will ever be, passionate about gaming. The very first thing that inspired me into electronics and computers, was the fun around playing and building games. </p><p>My most favourite hobby is programming a simple game whenever I pick up a new language or a computing platforms. To add some fun, this time, I wanted to build a small handheld gaming console from the scratch. </p><p>My family named this device "GameTiger" and the logo reflects it's name. I'll be talking about the logo more, later in the article. The device looks amateurish and I wanted to keep it that way for sometime until I can call the device complete, both in hardware and software. </p><h3 id="hardware">Hardware:</h3><p>The entire hardware is custom built and is based on Raspberry Pi Pico microcontroller. The choice of the MCU is based on its simplicity, cost and support for various tools. I know very well that with my expert level soldering skills, I'll definitely fry a few components. So I wanted it to be cheap so I don't spend too much. </p><!--kg-card-begin: markdown--><ul>
<li>MCU RP2040
<ul>
<li>32-bit dual ARM Cortex-M0+ Microcontroller</li>
<li>133 MHz Clock speed</li>
<li>264 KB SRAM</li>
<li>2 MB flash storage</li>
<li>26 GPIO pins</li>
</ul>
</li>
<li>LCD display module by Waveshare
<ul>
<li>Resolution: 240&#215;320</li>
<li>Color: 262K RGB (24bit RGB888)</li>
<li>Interface: SPI</li>
<li>Driver: ST7789</li>
<li>Backlight: LED</li>
<li>Operating voltage: 3.3V/5V</li>
</ul>
</li>
<li>Tactile Buttons</li>
<li>LiPo SHIM for Pico by Pimoroni
<ul>
<li>MCP73831 charger</li>
<li>XB6096I2S battery protector</li>
<li>Supports battery level measuring on VSYS pin</li>
</ul>
</li>
<li>Witty Fox Li-Ion Battery
<ul>
<li>Voltage: 3.7v</li>
<li>Capacity: 1000 mAh</li>
</ul>
</li>
</ul>
<!--kg-card-end: markdown--><h3 id="wiring">Wiring:</h3><p>The components are based on standard interfaces and thus nothing complicated in wiring. You can feel free to use different GPIO pins based on lot of tutorials but this is what I've used and configured in the software as default.</p><!--kg-card-begin: html--><table style="font-size: 16px; font-style: normal; font-variant-caps: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; text-decoration: none; box-sizing: border-box; border-spacing: 0px; border-collapse: collapse; margin-top: 0px; margin-bottom: 16px; display: block; width: max-content; max-width: 100%; overflow: auto; caret-color: rgb(201, 209, 217); color: rgb(201, 209, 217); font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";"><thead style="box-sizing: border-box;"><tr style="box-sizing: border-box; background-color: var(--color-canvas-default); border-top: 1px solid var(--color-border-muted);"><th style="box-sizing: border-box; padding: 6px 13px; font-weight: 600; border: 1px solid var(--color-border-default);">Component</th><th style="box-sizing: border-box; padding: 6px 13px; font-weight: 600; border: 1px solid var(--color-border-default);">Pin</th><th style="box-sizing: border-box; padding: 6px 13px; font-weight: 600; border: 1px solid var(--color-border-default);">Pico GPIO</th><th style="box-sizing: border-box; padding: 6px 13px; font-weight: 600; border: 1px solid var(--color-border-default);">Description</th></tr></thead><tbody style="box-sizing: border-box;"><tr style="box-sizing: border-box; background-color: var(--color-canvas-default); border-top: 1px solid var(--color-border-muted);"><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">LCD</td><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">VCC</td><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">VSYS</td><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">Power Input</td></tr><tr style="box-sizing: border-box; background-color: var(--color-canvas-subtle); border-top: 1px solid var(--color-border-muted);"><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);"></td><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">GND</td><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">GND</td><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">Ground</td></tr><tr style="box-sizing: border-box; background-color: var(--color-canvas-default); border-top: 1px solid var(--color-border-muted);"><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);"></td><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">DIN</td><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">GP11</td><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">MOSI pin of SPI, data transmitted</td></tr><tr style="box-sizing: border-box; background-color: var(--color-canvas-subtle); border-top: 1px solid var(--color-border-muted);"><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);"></td><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">CLK</td><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">GP10</td><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">SCK pin of SPI, clock pin</td></tr><tr style="box-sizing: border-box; background-color: var(--color-canvas-default); border-top: 1px solid var(--color-border-muted);"><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);"></td><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">CS</td><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">GP9</td><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">Chip selection of SPI, low active</td></tr><tr style="box-sizing: border-box; background-color: var(--color-canvas-subtle); border-top: 1px solid var(--color-border-muted);"><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);"></td><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">DC</td><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">GP8</td><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">Data/Command control pin (High:data; Low: command)</td></tr><tr style="box-sizing: border-box; background-color: var(--color-canvas-default); border-top: 1px solid var(--color-border-muted);"><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);"></td><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">RST</td><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">GP12</td><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">Reset pin, low active</td></tr><tr style="box-sizing: border-box; background-color: var(--color-canvas-subtle); border-top: 1px solid var(--color-border-muted);"><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);"></td><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">BL</td><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">GP13</td><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">Backlight control</td></tr><tr style="box-sizing: border-box; background-color: var(--color-canvas-default); border-top: 1px solid var(--color-border-muted);"><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">Buttons</td><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">Up</td><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">GPIO2</td><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">Up button in the keypad</td></tr><tr style="box-sizing: border-box; background-color: var(--color-canvas-subtle); border-top: 1px solid var(--color-border-muted);"><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);"></td><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">Down</td><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">GPIO0</td><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">Down button in the keypad</td></tr><tr style="box-sizing: border-box; background-color: var(--color-canvas-default); border-top: 1px solid var(--color-border-muted);"><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);"></td><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">Left</td><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">GPIO1</td><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">Left button in the keypad</td></tr><tr style="box-sizing: border-box; background-color: var(--color-canvas-subtle); border-top: 1px solid var(--color-border-muted);"><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);"></td><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">Right</td><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">GPIO3</td><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">Right button in the keypad</td></tr><tr style="box-sizing: border-box; background-color: var(--color-canvas-default); border-top: 1px solid var(--color-border-muted);"><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);"></td><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">A</td><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">GPIO4</td><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">A (Action) button in the keypad</td></tr><tr style="box-sizing: border-box; background-color: var(--color-canvas-subtle); border-top: 1px solid var(--color-border-muted);"><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);"></td><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">B</td><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">GPIO5</td><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">B (Back) button in the keypad</td></tr><tr style="box-sizing: border-box; background-color: var(--color-canvas-default); border-top: 1px solid var(--color-border-muted);"><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">LiPo SHIM</td><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);"></td><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);"></td><td style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">Directly mounted on Pico based on datasheet</td></tr></tbody></table><!--kg-card-end: html--><h3 id="software">Software:</h3><p>Yes, you read it correct, the chip has only 264 KB RAM and that a lot less for these days. To explain the complexity in building the software, the framebuffer alone for storing the on-screen pixel details takes 153.6 KB (320 width * 240 height * 2 bytes). While the LCD display supports upto 262K colors, I decided to use only 2 bytes for each pixel to save the RAM usage. To store RGB888, the total memory needed is 230 KB which is more than 85% of the RAM size. Also, we can't do double buffering like most games do, the traditional way. Or even storing a sprite sheet of the size of the screen into the RAM is also not possible. Below are the list of modules I've built into the software.</p><!--kg-card-begin: markdown--><ul>
<li>Operating System Drivers
<ul>
<li>Display driver over SPI using DMA (Direct Memory Access)</li>
<li>Button interrupts</li>
<li>Battery management system driver</li>
</ul>
</li>
<li>Framebuffer Library
<ul>
<li>Supports transparency</li>
<li>Direct streaming to display memory (partial/full updates)</li>
<li>Primitive shape drawing including Line, Circle, Rect and Fill Rect</li>
<li>Supports drawing images with alpha channel</li>
<li>All framebuffer operations support DMA (Direct Memory Access)</li>
</ul>
</li>
<li>Sprite sheet
<ul>
<li>Support for sprite sheet</li>
<li>Basic tilemap support</li>
</ul>
</li>
<li>Font system based on Sprite sheet</li>
<li>Menu system
<ul>
<li>Dynamically loading games</li>
<li>Hardware config
<ul>
<li>Display brightness</li>
<li>Display sleep time after inactivity</li>
</ul>
</li>
</ul>
</li>
<li>Filesystem
<ul>
<li>Support for SD card module to load game assets</li>
</ul>
</li>
</ul>
<!--kg-card-end: markdown--><p>The most complex part of software was the frame-buffer implementation. There are 2 modes available for the games, one of-course using the framebuffer that takes 154 kbs of the RAM and update the display memory periodically, or just stream the changes directly to the display. The other complexity is using both the cores available in the chip. Unlike CPUs, the MCU cores are bit different in the way you can use threads in your code. </p><p>Just to give you an idea on the complexity again, the splash screen that shows the tiger logo uses full frame buffer and loads the image which is another 32 kb along with a basic font image which is 12 kb. The total RAM used is around 200 kbs already, so my code had to be written very carefully on variable usage and memory allocation. Ex: Use 8bit variable type whereever possible. I can't assume int by default for anything, as it takes 32 bits. </p><figure class="kg-card kg-embed-card"><iframe width="200" height="113" src="https://www.youtube.com/embed/edIZAm9zVC8?feature=oembed" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></figure><p>The sample game as always is Snake game very similar to what we use to have in Nokia 1100 handsets. The Frame-buffer is well optimised to achieve a target of 30 frames per second. The Snake game achieves more than 44 FPS on a default settings without overclocking.</p><h3 id="more-to-come">More to come:</h3><p>I am planning to add more games to this hardware in future when I find time. Shall keep posting updates here. I am also planning to create a 3d printed case for this device to make it look more professional. </p><h3 id="source-code">Source code:</h3><p>The entire source of <a href="https://github.com/codetiger/GameTiger-Console">GameTiger Console</a> is available in Github. Feel free to share your feedback. Also share the games or applications you would like to see on this device.</p>]]></content:encoded></item><item><title><![CDATA[Remote ePaper display using ESP32]]></title><description><![CDATA[<p>I had a 7.8 inch ePaper display from Waveshare lying around for a while. This is an expensive eInk display with 1872x1404 pixel resolution that supports 4 bit grayscale values. </p><p><strong>Objective:</strong> Building a photo frame with the content streamed from my home server built using a Raspberry Pi. The</p>]]></description><link>https://codetiger.github.io/blog/remote-epaper-display-using-esp32/</link><guid ispermalink=false>61b8453f22d8ff0cb28948bc</guid><category><![CDATA[electronics]]></category><category><![CDATA[ESP32]]></category><category><![CDATA[raspberry pi]]></category><category><![CDATA[ePaper]]></category><category><![CDATA[eInk]]></category><category><![CDATA[display]]></category><dc:creator><![CDATA[Harishankar]]></dc:creator><pubdate>Sat, 29 Jan 2022 03:00:10 GMT</pubdate><media:content url=https://codetiger.github.io/blog/content/images/2022/01/E695CC21-D1FA-4CEA-865C-77B266A02730_1_105_c.jpeg medium=image><content:encoded><![CDATA[<img src="./..//content/images/2022/01/E695CC21-D1FA-4CEA-865C-77B266A02730_1_105_c.jpeg" alt="Remote ePaper display using ESP32"><p>I had a 7.8 inch ePaper display from Waveshare lying around for a while. This is an expensive eInk display with 1872x1404 pixel resolution that supports 4 bit grayscale values. </p><p><strong>Objective:</strong> Building a photo frame with the content streamed from my home server built using a Raspberry Pi. The RPi will stream family pics available in the storage and intermittently show home power consumption dashboard on screen. </p><p><strong>Challenges:</strong> As with any project, this one had very particular challenge of keeping the hardware simple. ESP32 has Wifi support but not enough RAM to hold the frame buffer needed. The display has 2628288 pixels each needs 4 bit which makes it 1.25 MB. The MCU that is going to drive the display needs &#160;at least 1.25MB as a frame buffer. The reason for this expectation is, the display needs the data available to the driver in a sequence of commands. </p><p>Our powerful ESP32 has only 500 KB of RAM and not all is available to the program. The display is driven by IT8951 chip module. The available driver for IT8951, open sourced by the device manufacturer does not support streaming or ESP32 chip. Their code assumes the entire image buffer is available before pushing it to the driver. </p><p>After taking a look at how the code works, I had some hope that this can be achieved by rewriting the code. However, the chip and the display were going to be powered using battery and needs to be as efficient as possible. I had to rewrite most part of the buffering and remove the need to RAM. </p><p>I used a TCP connection between RPi and ESP32. My ESP32 code will listen to TCP port 8319. The RPi code is written using python and configured as a cron job. Every time the code randomly pushes an image from a given directory. The whole post processing like resizing and color conversion had to be done at RPi as this cannot be handled in the ESP32 for lack of RAM. The ESP32 code receives the sequence of bytes from RPi and directly streams it to the IT8951 module. I was able to achieve this easily and got an image displayed on screen. Please ignore the noise in the image which comes from encoding issue which I solved later. </p><figure class="kg-card kg-image-card"><img src="./..//content/images/2022/01/FE4A22F8-115B-4A3A-BF47-174564B4F3F0_1_105_c.jpeg" class="kg-image" alt="Remote ePaper display using ESP32" loading="lazy" width="1024" height="768" srcset="https://codetiger.github.io/blog/content/images/size/w600/2022/01/FE4A22F8-115B-4A3A-BF47-174564B4F3F0_1_105_c.jpeg 600w, https://codetiger.github.io/blog/content/images/size/w1000/2022/01/FE4A22F8-115B-4A3A-BF47-174564B4F3F0_1_105_c.jpeg 1000w, https://codetiger.github.io/blog/content/images/2022/01/FE4A22F8-115B-4A3A-BF47-174564B4F3F0_1_105_c.jpeg 1024w" sizes="(min-width: 720px) 720px"></figure><p>After fixes the noise issue, and getting a proper image on screen, I had another challenge. It took upto 30 seconds to stream a full size image from RPi which is way too much for what we are doing. I realised the TCP overhead for each packet added-up and eventually slowed down the whole thing. </p><p>I added intermediate buffering. Our ESP32 has some RAM which cannot be ignored. So I decided to buffer the data stream which should speed up the task. Instead of reading each byte from the TCP socket, I configured the code to read a buffer of 1KB. The buffer size is configurable. After reading the buffer, TCP socket is free to receive more data and meanwhile, I can push the data to IT8951. When trying with 1KB, I was able to stream the content in less than a second which was my target. </p><p>The reason for having 1 second as a target is, the refresh rate of the display is more than a second, so I anyway have to wait for the display to get ready. Finally the streaming worked perfect and but images had some issue. If you notice the below picture, you see the text pixelated. This was definitely not how the image looked. </p><figure class="kg-card kg-image-card"><img src="./..//content/images/2022/01/FE91959F-EABF-4F1A-A4E8-D2D6E151ACEC_1_105_c.jpeg" class="kg-image" alt="Remote ePaper display using ESP32" loading="lazy" width="1044" height="752" srcset="https://codetiger.github.io/blog/content/images/size/w600/2022/01/FE91959F-EABF-4F1A-A4E8-D2D6E151ACEC_1_105_c.jpeg 600w, https://codetiger.github.io/blog/content/images/size/w1000/2022/01/FE91959F-EABF-4F1A-A4E8-D2D6E151ACEC_1_105_c.jpeg 1000w, https://codetiger.github.io/blog/content/images/2022/01/FE91959F-EABF-4F1A-A4E8-D2D6E151ACEC_1_105_c.jpeg 1044w" sizes="(min-width: 720px) 720px"></figure><p>After fighting for a whole day, I figured out that I was sending the pixel data in BIG Endian formate which the device was configured to receive in LITTLE endian format. &#160;After fixing this issue, the picture looked perfect on screen. unfortunately many open-source drivers available in Github has similar issue. The issue does not show-up well when you display an image, but is very much noticeable when you display text. </p><figure class="kg-card kg-image-card"><img src="./..//content/images/2022/01/0EB99228-8C55-4F3A-83AD-CC8C73C0F983_1_105_c.jpeg" class="kg-image" alt="Remote ePaper display using ESP32" loading="lazy" width="1024" height="768" srcset="https://codetiger.github.io/blog/content/images/size/w600/2022/01/0EB99228-8C55-4F3A-83AD-CC8C73C0F983_1_105_c.jpeg 600w, https://codetiger.github.io/blog/content/images/size/w1000/2022/01/0EB99228-8C55-4F3A-83AD-CC8C73C0F983_1_105_c.jpeg 1000w, https://codetiger.github.io/blog/content/images/2022/01/0EB99228-8C55-4F3A-83AD-CC8C73C0F983_1_105_c.jpeg 1024w" sizes="(min-width: 720px) 720px"></figure><p>In the picture above, I've scrapped the Grafana dashboard and streamed it to the display. I used selenium to take screenshot of the page and used the same code to push it to the display. The entire source code is available <a href="https://github.com/codetiger/ePaper-display-using-ESP32">here</a>. </p>]]></content:encoded></item><item><title><![CDATA[Home power consumption monitoring using ESP32]]></title><description><![CDATA[<p>Its always fun to collect data around you and understand your needs better. When it comes to power consumption, end of the month bill gives us a pretty good view, but I wanted to make it slightly interesting. I wanted to collect power consumption every second in my house and</p>]]></description><link>https://codetiger.github.io/blog/home-power-consumption-monitoring-using-esp32/</link><guid ispermalink=false>61caa7a35617d43a007a57e7</guid><category><![CDATA[ESP32]]></category><category><![CDATA[raspberry pi]]></category><category><![CDATA[CT-sensor]]></category><category><![CDATA[electronics]]></category><dc:creator><![CDATA[Harishankar]]></dc:creator><pubdate>Tue, 28 Dec 2021 07:49:57 GMT</pubdate><media:content url=https://codetiger.github.io/blog/content/images/2022/01/home-monitoring-grafana-dashboard.jpg medium=image><content:encoded><![CDATA[<img src="./..//content/images/2022/01/home-monitoring-grafana-dashboard.jpg" alt="Home power consumption monitoring using ESP32"><p>Its always fun to collect data around you and understand your needs better. When it comes to power consumption, end of the month bill gives us a pretty good view, but I wanted to make it slightly interesting. I wanted to collect power consumption every second in my house and see how the data looks like. </p><h3 id="components-used">Components used:</h3><ol><li>ESP WROOM 32 MCU Module - (<a href="https://robu.in/product/esp-wroom-32-wifi-bluetooth-networking-smart-component-development-board/">Robu.in</a>)</li><li>SCT-013-030 Non-invasive AC Current Sensor Clamp Sensor - (<a href="https://robu.in/product/sct-013-030-non-invasive-ac-current-sensor-clamp-sensor-30a/">Robu.in</a>)</li><li>100k Ohm resistors - 2 pieces</li><li>10uF capacitor - 1 piece</li><li>3.5mm jack female connector - 1 piece</li></ol><h3 id="wiring-diagram">Wiring diagram:</h3><p>The wiring diagram were taken mostly from <a href="https://savjee.be/2019/07/Home-Energy-Monitor-ESP32-CT-Sensor-Emonlib/">this article</a> and <a href="https://openenergymonitor.org">OpenEnergyMonitor</a> project. The wiring diagram is same as the standard ones mentioned in these websites. I just didn't want to copy or redo the same as the other articles are already explaining these things at the best. </p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="./..//content/images/2021/12/esp32-energy-monitor-front.jpg" class="kg-image" alt="Home power consumption monitoring using ESP32" loading="lazy" width="2000" height="3012" srcset="https://codetiger.github.io/blog/content/images/size/w600/2021/12/esp32-energy-monitor-front.jpg 600w, https://codetiger.github.io/blog/content/images/size/w1000/2021/12/esp32-energy-monitor-front.jpg 1000w, https://codetiger.github.io/blog/content/images/size/w1600/2021/12/esp32-energy-monitor-front.jpg 1600w, https://codetiger.github.io/blog/content/images/2021/12/esp32-energy-monitor-front.jpg 2112w" sizes="(min-width: 720px) 720px"><figcaption>ESP32 Energy Monitor Circuit</figcaption></figure><figure class="kg-card kg-image-card kg-card-hascaption"><img src="./..//content/images/2021/12/esp32-energy-monitor-back.jpg" class="kg-image" alt="Home power consumption monitoring using ESP32" loading="lazy" width="2000" height="2830" srcset="https://codetiger.github.io/blog/content/images/size/w600/2021/12/esp32-energy-monitor-back.jpg 600w, https://codetiger.github.io/blog/content/images/size/w1000/2021/12/esp32-energy-monitor-back.jpg 1000w, https://codetiger.github.io/blog/content/images/size/w1600/2021/12/esp32-energy-monitor-back.jpg 1600w, https://codetiger.github.io/blog/content/images/2021/12/esp32-energy-monitor-back.jpg 2087w" sizes="(min-width: 720px) 720px"><figcaption>ESP32 Energy Monitor Circuit</figcaption></figure><p>As you can clearly see, my soldering skills are not that great. :-)</p><h3 id="software">Software: </h3><p>With not much changes in the hardware, I did a lot of research on making the software better. Especially with ESP32 having issues in accuracy with its ADC controller, I spent a lot of time making it better. <br>I used the open source Emon library and added a look up table for my ESP32 ADC which gives a very good results in accurately measuring the analog input. As it is well known each ESP32 needs to be calibrated for ADC. While the recently manufactured ESP32 are calibrated at factory, I still didn't find it quite accurate in my case. So I calibrated and generated a look up table for my chip. The calibration code is available <a href="https://github.com/e-tinkers/esp32-adc-calibrate">here</a>. </p><p>The entire code is available here: <a href="https://github.com/codetiger/PowerConsumptionMonitor-ESP32">ESP32 Home energy monitoring</a></p><p>The ESP32 sketch works as a prometheus exporter making it easy to log the data easily in timeseries. Prometheus also has been my personal favourite in terms of resource usage. </p><figure class="kg-card kg-image-card"><img src="./..//content/images/2021/12/energy-monitor-grafana.jpg" class="kg-image" alt="Home power consumption monitoring using ESP32" loading="lazy" width="1915" height="980" srcset="https://codetiger.github.io/blog/content/images/size/w600/2021/12/energy-monitor-grafana.jpg 600w, https://codetiger.github.io/blog/content/images/size/w1000/2021/12/energy-monitor-grafana.jpg 1000w, https://codetiger.github.io/blog/content/images/size/w1600/2021/12/energy-monitor-grafana.jpg 1600w, https://codetiger.github.io/blog/content/images/2021/12/energy-monitor-grafana.jpg 1915w" sizes="(min-width: 720px) 720px"></figure><p>Finally the data is available in Grafana. As I already have a Raspberry Pi running in my house for various other things, I added Prometheus and Grafana for monitoring the energy consumption as well. </p><h3 id="final-packing">Final packing:</h3><figure class="kg-card kg-image-card kg-card-hascaption"><img src="./..//content/images/2021/12/E391E3DB-AEEA-4FEA-B16F-1BF1C112E07D_1_105_c.jpeg" class="kg-image" alt="Home power consumption monitoring using ESP32" loading="lazy" width="768" height="1024" srcset="https://codetiger.github.io/blog/content/images/size/w600/2021/12/E391E3DB-AEEA-4FEA-B16F-1BF1C112E07D_1_105_c.jpeg 600w, https://codetiger.github.io/blog/content/images/2021/12/E391E3DB-AEEA-4FEA-B16F-1BF1C112E07D_1_105_c.jpeg 768w" sizes="(min-width: 720px) 720px"><figcaption>ESP32 + SCT-13-030 CT sensor for home power monitoring</figcaption></figure>]]></content:encoded></item><item><title><![CDATA[RaLiSat-1 Base station system design]]></title><description><![CDATA[<p>For my high altitude balloon project, I am designing a portable base station system to recieve the transmission from the payload. </p><h3 id="hardware">Hardware:</h3><p>The base station is a Raspberry Pi 3B+ based system with Lora module E32-868T30D from manufacturer Ebyte. This is very much the same module that I've</p>]]></description><link>https://codetiger.github.io/blog/ground-station/</link><guid ispermalink=false>61b875be22d8ff0cb28948cb</guid><category><![CDATA[Near Space]]></category><category><![CDATA[RaLiSat-1]]></category><category><![CDATA[raspberry pi]]></category><category><![CDATA[lora]]></category><category><![CDATA[electronics]]></category><dc:creator><![CDATA[Harishankar]]></dc:creator><pubdate>Tue, 14 Dec 2021 11:22:19 GMT</pubdate><content:encoded><![CDATA[<p>For my high altitude balloon project, I am designing a portable base station system to recieve the transmission from the payload. </p><h3 id="hardware">Hardware:</h3><p>The base station is a Raspberry Pi 3B+ based system with Lora module E32-868T30D from manufacturer Ebyte. This is very much the same module that I've used in the payload for transmission. I've also added an active buzzer to sound a beep whenever the system receives location data which is designed to happen every 5 seconds. The buzzer helped a lot during the testing phase when I had to keep this constantly running in various conditions. I believe this will help during actual flight as well, as the chasing is going to be continuous. </p><h3 id="software">Software:</h3><p>The software system is basically simple and uses the same Lora classes from the <a href="https://github.com/codetiger/rpi-hab/blob/main/habmonitor.py">payload source code</a>. The objective is to just wait for data from the payload and send acknowledgement. Internally the payload sensor data is decoded and stored in InfluxDB. I am using Grafana integrated to InfluxDB, to pull a beautify dashboard for quick data visualisation. </p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="./..//content/images/2021/12/RaLiSat-1-base-station-grafana-dashboard-1.jpg" class="kg-image" alt loading="lazy" width="1920" height="1056" srcset="https://codetiger.github.io/blog/content/images/size/w600/2021/12/RaLiSat-1-base-station-grafana-dashboard-1.jpg 600w, https://codetiger.github.io/blog/content/images/size/w1000/2021/12/RaLiSat-1-base-station-grafana-dashboard-1.jpg 1000w, https://codetiger.github.io/blog/content/images/size/w1600/2021/12/RaLiSat-1-base-station-grafana-dashboard-1.jpg 1600w, https://codetiger.github.io/blog/content/images/2021/12/RaLiSat-1-base-station-grafana-dashboard-1.jpg 1920w" sizes="(min-width: 720px) 720px"><figcaption>Grafana Dashboard - High altitude balloon project - RaLiSat-1</figcaption></figure><h3 id="payload-chasing-plan">Payload chasing plan:</h3><p>Tha idea is to use the base station system connected with a Wifi dongle and a power-bank, so the Grafana dashboard can be accessed using a laptop. The Map shows the latests position of the payload and will help chase it during the return fall. Hoping this will work! Stay tuned for the final results. </p>]]></content:encoded></item><item><title><![CDATA[RaLiSat-1 design challenges - Payload internal temperature]]></title><description><![CDATA[<p>As we know, the higher you reach in altitude, the lower the temperature and pressure is. At around 25 kms which is my target for this project, the temperature is -56&#176;C. This is way beyond the range of operating temperature for any commercial electronic. </p><p><strong>Generic Solution: </strong>Most projects</p>]]></description><link>https://codetiger.github.io/blog/ralisat-1-payload-design-challenges/</link><guid ispermalink=false>61b8367822d8ff0cb2894773</guid><category><![CDATA[RaLiSat-1]]></category><category><![CDATA[Near Space]]></category><category><![CDATA[raspberry pi]]></category><category><![CDATA[electronics]]></category><dc:creator><![CDATA[Harishankar]]></dc:creator><pubdate>Tue, 14 Dec 2021 07:31:02 GMT</pubdate><content:encoded><![CDATA[<p>As we know, the higher you reach in altitude, the lower the temperature and pressure is. At around 25 kms which is my target for this project, the temperature is -56&#176;C. This is way beyond the range of operating temperature for any commercial electronic. </p><p><strong>Generic Solution: </strong>Most projects use a Polystyrene boxes and add a heat source like hand warmer to keep the container within the right temperature. This approach further increases the size of the payload and the weight. &#160;</p><p><strong>Solution Used:</strong> As a design target, I wanted the payload weight to be less than 240 grams. Primary reason is to use as less helium as possible and use 350 gram balloon. I built a styrofoam cube using layered sheets with all electronic components within each layer and enclosed it. The components were fitted within small engraving in the layers and used super glue to fit the layers perfectly. Obviously the GPS ceramic antenna, environment sensor, camera and Lora antenna had to be left outside. The overall design looks like the below image. </p><figure class="kg-card kg-image-card"><img src="./..//content/images/2021/12/IMG_5967.jpg" class="kg-image" alt loading="lazy" width="1024" height="537" srcset="https://codetiger.github.io/blog/content/images/size/w600/2021/12/IMG_5967.jpg 600w, https://codetiger.github.io/blog/content/images/size/w1000/2021/12/IMG_5967.jpg 1000w, https://codetiger.github.io/blog/content/images/2021/12/IMG_5967.jpg 1024w" sizes="(min-width: 720px) 720px"></figure><p><strong>Test Scenarios:</strong> To test the design, the primary approach I tried was, leaving the system inside a freezer (-20&#176;C) to see the min/max CPU temperatures for upto 2 hours. My test criteria was to keep the CPU temperature between 35&#176;C and 75&#176;C. This is very hard to accomplish, as the Raspberry Pi Zero does not have any airflow and easily reached 75&#176;C even when put inside the freezer. Then I make lot of performance tuning to the system to balance the CPU usage and heat produced. At a certain point, I was able to see the temperature was stable at most environmental conditions. I tested in direct sunlight, inside the freezer and room temperature, and the CPU temperature in all conditions were well within the range. </p><h3 id="conclusion">Conclusion:</h3><p>Finally I was able to reach a point where, I had to never worry about the internal temperatures reaching unexpected ranges. But remember, I took around a month to stablise this. I tried to under-clock the Raspberry Pi, but gave up on that option as it reduced the heat generation drastically and the internal CPU temperatures reached unexpected low 10&#176;C within 25 mins in the freezer. I couldn't reach a stable temperature range with enough computing power when under-clocking the RPi. I did try writing a CPU intensive &#160;bash script which will run for few seconds to increase the temperature if it went below certain range. </p><blockquote>Finally, understanding what part of the code produces more heat and configuring how often it can run, helped solve this problem. </blockquote><p>The GPU usage, especially the camera image capture and resizing part was the one which produced enough heat, to make it work. The entire code is available in my GitHub project <a href="https://github.com/codetiger/rpi-hab">RPi-Hab</a></p>]]></content:encoded></item><item><title><![CDATA[RaLiSat-1 Payload system design]]></title><description><![CDATA[<p>To start with, I had basic goals for designing the payload system. Including basic sensors necessary for the tracking, camera to capture the beauty and the design to sustain the system at harsh climatic conditions in the sky. </p><h3 id="goals-for-the-first-flight">Goals for the first flight:</h3><ol><li>Use a single board computer of smallest</li></ol>]]></description><link>https://codetiger.github.io/blog/ralisat-1-payload-design/</link><guid ispermalink=false>61b5721e22d8ff0cb289460c</guid><category><![CDATA[RaLiSat-1]]></category><category><![CDATA[Near Space]]></category><category><![CDATA[electronics]]></category><category><![CDATA[GPS]]></category><category><![CDATA[lora]]></category><category><![CDATA[raspberry pi]]></category><dc:creator><![CDATA[Harishankar]]></dc:creator><pubdate>Sun, 12 Dec 2021 06:33:11 GMT</pubdate><content:encoded><![CDATA[<p>To start with, I had basic goals for designing the payload system. Including basic sensors necessary for the tracking, camera to capture the beauty and the design to sustain the system at harsh climatic conditions in the sky. </p><h3 id="goals-for-the-first-flight">Goals for the first flight:</h3><ol><li>Use a single board computer of smallest form-factor possible to record data</li><li>Add a camera capable of taking pictures at 1 sec interval</li><li>Add Temperature, humidity, and pressure sensors</li><li>GPS module for tracking</li><li>RF Module to transmit data to ground station</li><li>Battery enough to power the flight time and beyond</li></ol><p>With simple goals laid out, I started working on doing some research on each components. For my first flight, I wanted to keep things simple so I get the experience of actual difficulty in the first place. Obviously I've more ambitions on better things in future, but didn't want to keep designing things rather try something. </p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="./..//content/images/2021/12/payload-design.png" class="kg-image" alt loading="lazy" width="1024" height="576" srcset="https://codetiger.github.io/blog/content/images/size/w600/2021/12/payload-design.png 600w, https://codetiger.github.io/blog/content/images/size/w1000/2021/12/payload-design.png 1000w, https://codetiger.github.io/blog/content/images/2021/12/payload-design.png 1024w" sizes="(min-width: 720px) 720px"><figcaption>Flight computer design - RaLiSat-1</figcaption></figure><h3 id="raspberry-pi-and-camera">Raspberry Pi and Camera:</h3><p>I decided to go with a Raspberry Pi Zero based payload system so I can do enough computing without my hands tied like in-case of microprocessors. Infact, RPi Zero was bit too much for my goal, however, it comes handy and I already had one from my previous projects. The main intension was to keep the design as plug-n-play as possible. I previous attempt in flight computer failed in 2008 primarily because of this reason. RPi camera was an easy option to decide as it is very compact and integration is easy.</p><h3 id="bme680-environmental-sensors">BME680 Environmental Sensors: </h3><p>SeeedStudio's BME680 sensor module looked very impressive as it supports i2c interface and had all sensors I expected in one module. One downside, the pressure and temperature sensors had an operating range of 300-1100hPa and -40~+85 respectively. With a goal of reaching 25 kms altitude, the environment is going to be at -56 degree celsius and 25 hPa which are both out of the range of the sensors. However, beyond this reading it is very hard to find a sensor that is cheap with integration options as easy as this one. So I decided to go anyway and see how it works. </p><h3 id="gps-module">GPS Module:</h3><p>With no knowledge about how the pressure sensor will work beyond 300 hPa, the only other option is to use a GPS module that will work with target altitude. I chose UBlox M8N which had a max altitude of upto 50kms using the Airborne mode. Again this was another easy choice for me. The <a href="https://codetiger.github.io/blog/interfacing-ublox-gps-m8n-with-raspberry-pi/">UBlox M8N GPS module integration and source code</a> are explained in this previous article. </p><h3 id="lora-e32-868t30d-as-rf-module">Lora E32-868T30D as RF module:</h3><p>For tracking the flight, I wanted the GPS coordinates to be transferred to the ground station at frequent intervals. Lora was an easy choice and Ebyte E32 modules had UART interface which had lot of advatages. <a href="https://codetiger.github.io/blog/transfer-images-over-lora-e32-module/">Integrating E32-868T30D with Raspberry Pi is explained here</a>. The primary purpose was to send GPS co-ordinates but eventually I decided to send almost all data recorded including images through Lora module after seeing the capability. The source code and details are provided in <a href="https://codetiger.github.io/blog/sending-large-data-like-images-over-lora/">this article</a>. Making my program to efficiently use Lora to send large images and data took a lot of time. </p><h3 id="battery">Battery:</h3><p>I used an old, small and compact 6000 mAh power bank from my uncle and ripped-off the case to reduce the weight. The battery was able to last upto 5 hours which was more than sufficient for the entire flight time including tracking. &#160;</p><p>The modules were put-together to work and the entire source code took around 3 months to stabilise and fine-tune. The challenges faced in the design shall be discussed in another post. Stay tuned. </p>]]></content:encoded></item><item><title><![CDATA[Aquarium automation using Raspberry Pi]]></title><description><![CDATA[<p>As a childhood desire, I always wanted to try setup an aquarium at my home. The desire was always there deep inside and never sparked until my daughter had to do some school activity on aquariums. So we decided to buy a small 10 liter aquarium tank with 3 molly</p>]]></description><link>https://codetiger.github.io/blog/aquarium-automation-using-raspberry-pi/</link><guid ispermalink=false>61b0a32b22d8ff0cb289430e</guid><category><![CDATA[raspberry pi]]></category><category><![CDATA[electronics]]></category><category><![CDATA[Aquarium]]></category><dc:creator><![CDATA[Harishankar]]></dc:creator><pubdate>Wed, 08 Dec 2021 14:05:49 GMT</pubdate><content:encoded><![CDATA[<p>As a childhood desire, I always wanted to try setup an aquarium at my home. The desire was always there deep inside and never sparked until my daughter had to do some school activity on aquariums. So we decided to buy a small 10 liter aquarium tank with 3 molly fishes. To our surprise, the fishes started giving birth and the desire got intensified. So we planned to setup a 150 Liter large aquarium in our house and do some lanscaping with beautiful plants. </p><p>After 6 months of hardwork, we were able to reach to the below state. Please don't judge me on the landscaping skills. Our objective was to simulate the closest natural habitate of the fishes we had. </p><figure class="kg-card kg-image-card"><img src="./..//content/images/2021/12/IMG_0571-1.jpeg" class="kg-image" alt loading="lazy" width="2000" height="926" srcset="https://codetiger.github.io/blog/content/images/size/w600/2021/12/IMG_0571-1.jpeg 600w, https://codetiger.github.io/blog/content/images/size/w1000/2021/12/IMG_0571-1.jpeg 1000w, https://codetiger.github.io/blog/content/images/size/w1600/2021/12/IMG_0571-1.jpeg 1600w, https://codetiger.github.io/blog/content/images/size/w2400/2021/12/IMG_0571-1.jpeg 2400w" sizes="(min-width: 720px) 720px"></figure><h3 id="challenges-and-why-automation">Challenges and why automation:</h3><p>If you are an aquarium enthusiast like me and have tried planted tank, the challenges are going to be very obvious. You need to maintain lot of things like good bacteria level, CO2 level plants, O2 level for fishes, overall lighting for plants, fish food, and ofcourse plants need nutritions as well. The challenges grow from there to weekly water maintanence and trimming the plants. Overall, I got bit frustrated to repeatedly do lot of these things on a daily basis. As a programmer, my brain motivated to automate it. The overall challenge is to schedule various equipements based on below requirements.</p><ol><li>High intensity plant lights need to be switched on for only a few hours during the day.</li><li>Low intensity light needs to be ON for an before and after plant lights are ON. Just to simulate dawn and dusk.</li><li>CO2 needs to be ON around the same time as high intensity light as the plants will only consume CO2 when there is light. The CO2 tank needs to be switched off 30 mins before the high intesity lights to save CO2.</li><li>Air pump to bring up the O2 level after the CO2 is OFF. O2 is essential for the fishes and plants at night, so the pump has to work all the time other than CO2 flow.</li><li>Heavy duty filter needs to work only for few hours of the day as it should be enough to clean up the dirt and fish waste. There is another filter that work round the clock which is less powerful.</li><li>Water cooler to bring down and maintain the water temperature during the day time. My location is mostly very hot during the day. </li><li>Did I forget about feeding the fishes? Yes, I made a small feeder using a motor and food container with a small hole. </li></ol><h3 id="electronics">Electronics:</h3><p>The overall automation setup is very simple, as all these equipments already were connected to power and only needed manual swtching on and off. I decided to go with a Raspberry Pi 3 B+ and a relay controller module. The wiring is simple as the relay module needs to be connected to 8 GPIO pins for On/Off signal. </p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="./..//content/images/2021/12/8-channel-relay-module-10a-640x640.jpg-copy.jpg" class="kg-image" alt loading="lazy" width="470" height="205"><figcaption>Relay module</figcaption></figure><p>The overall setup had the relay module connected to a power extension so the same setup can be reused in future. Below image shows the power extension with all exquipements connected and the cardboard box has the relay module and Raspberry Pi.</p><figure class="kg-card kg-image-card"><img src="./..//content/images/2021/12/B43DBC96-DB56-4763-BC71-2BC4E0A62A80_1_105_c.jpeg" class="kg-image" alt loading="lazy" width="1023" height="768" srcset="https://codetiger.github.io/blog/content/images/size/w600/2021/12/B43DBC96-DB56-4763-BC71-2BC4E0A62A80_1_105_c.jpeg 600w, https://codetiger.github.io/blog/content/images/size/w1000/2021/12/B43DBC96-DB56-4763-BC71-2BC4E0A62A80_1_105_c.jpeg 1000w, https://codetiger.github.io/blog/content/images/2021/12/B43DBC96-DB56-4763-BC71-2BC4E0A62A80_1_105_c.jpeg 1023w" sizes="(min-width: 720px) 720px"></figure><h3 id="you-should-have-lot-of-questions">You should have lot of questions:</h3><p>Why use a full blown computer while you can use a simple timer chip or micro controller for this? <br><strong>Ans:</strong> I've built a Web interface which will allow my family to manually override the config if needed and will also show the current state of the equipments. For example, we wanted the high intensity lights to be switched on if someone wants to take a look at the Aquarium. The below image shows the web page to control the individual equipments manually.</p><figure class="kg-card kg-image-card"><img src="./..//content/images/2021/12/image-1.png" class="kg-image" alt loading="lazy" width="560" height="1213"></figure><p>On top of this, I've been already using this Raspberry Pi as a home server and local DNS server with PiHole software running. The whole source code is available in my <a href="https://github.com/codetiger/AquariumControl">Github Aquarium project</a>.</p><h3 id="stability-of-the-setup">Stability of the setup:</h3><p>I've been running this setup for almost 3 years in a row without any issues. No wait, with all known issues fixed. And the Aquarium managed to last for 8 months without any human intervension during the Covid-19 country wide lockdown. We had to move to our native town early during the lockdown and couldn't goto the citi for 8 months. All we had was this automated setup that worked well and kept most fishes alive. The only manual work during the last 2 years, was changing water and refilling fish food once in 3 to 5 months. </p><blockquote>I would say, this was one of the remarkable works I've every done to save lives. :-) </blockquote>]]></content:encoded></item><item><title><![CDATA[Interfacing Ublox GPS M8N with Raspberry Pi]]></title><description><![CDATA[<p>Ublox GPS M8N module support UART communication and its fairly integrate with your Raspberry Pi. Just connecting to power and Rx wires will allow you to read the GPS NMEA messages. However the module is much more capable than just sending messages in raw text format. The module supports lot</p>]]></description><link>https://codetiger.github.io/blog/interfacing-ublox-gps-m8n-with-raspberry-pi/</link><guid ispermalink=false>61ae0d0222d8ff0cb289429e</guid><category><![CDATA[raspberry pi]]></category><category><![CDATA[GPS]]></category><category><![CDATA[electronics]]></category><dc:creator><![CDATA[Harishankar]]></dc:creator><pubdate>Wed, 08 Dec 2021 04:51:30 GMT</pubdate><content:encoded><![CDATA[<p>Ublox GPS M8N module support UART communication and its fairly integrate with your Raspberry Pi. Just connecting to power and Rx wires will allow you to read the GPS NMEA messages. However the module is much more capable than just sending messages in raw text format. The module supports lot of configurations and binary mode which is much easier to handle. </p><h3 id="wiring">Wiring:</h3><p>In my case, I was using Tx/Rx wires for another module so I ran out of UART ports in my Raspberry Pi Zero. As the Zero has only one UART pair and also does not have an inbuilt USB hub, I decided to use the micro USB port and hard wired a USB UART module directly to the Pi Zero board. </p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="./..//content/images/2021/12/ublox-m8n-gps.png" class="kg-image" alt loading="lazy" width="720" height="405" srcset="https://codetiger.github.io/blog/content/images/size/w600/2021/12/ublox-m8n-gps.png 600w, https://codetiger.github.io/blog/content/images/2021/12/ublox-m8n-gps.png 720w" sizes="(min-width: 720px) 720px"><figcaption>Ublox M8N GPS Module wiring with CP2102 and Raspberry Pi&#160;</figcaption></figure><h3 id="code">Code:</h3><p>The GPS Class in my project imports the ublox python module which is available <a href="https://github.com/tridge/pyUblox">here</a>. This module allows us to configure to work in binary mode and give use the function to configure frequency of various messages. You can configure dynamic model which is very essential for my project as altitude calculation is more important for my project. </p><!--kg-card-begin: markdown--><pre><code>#!/usr/bin/env python3
import logging, math
from ublox import *
from threading import Thread
class GPSModule(Thread):
gps = None
latitude = 0.0
longitude = 0.0
altitude = 0.0
fix_status = 0
satellites = 0
healthy = True
onHighAltitude = False
def __init__(self, portname="/dev/ttyUSB0", timeout=2, baudrate=9600):
logging.getLogger("HABControl")
logging.info('Initialising GPS Module')
try:
self.gps = UBlox(port=portname, timeout=timeout, baudrate=baudrate)
self.gps.set_binary()
self.gps.configure_poll_port()
self.gps.configure_solution_rate(rate_ms=1000)
self.gps.set_preferred_dynamic_model(DYNAMIC_MODEL_PEDESTRIAN)
self.gps.configure_message_rate(CLASS_NAV, MSG_NAV_POSLLH, 1)
self.gps.configure_message_rate(CLASS_NAV, MSG_NAV_SOL, 1)
Thread.__init__(self)
self.healthy = True
self.start()
except Exception as e:
logging.error('Unable to initialise GPS: %s' % str(e), exc_info=True)
self.gps = None
self.healthy = False
def run(self):
while self.healthy:
self.readData()
time.sleep(1.0)
def checkPressure(self, pressure):
alt = 0.0
if pressure is not 0:
alt = 44330.0 * (1.0 - math.pow(pressure / 1013.25, 0.1903))
self.checkAltitude(alt)
def checkAltitude(self, altitude):
if altitude is not 0:
if altitude > 9000 and not self.onHighAltitude:
self.onHighAltitude = True
self.gps.set_preferred_dynamic_model(DYNAMIC_MODEL_AIRBORNE1G)
if self.onHighAltitude and altitude &lt; 8000:
self.onHighAltitude = False
self.gps.set_preferred_dynamic_model(DYNAMIC_MODEL_PEDESTRIAN)
def readData(self):
try:
msg = self.gps.receive_message()
if msg is not None:
logging.debug(msg)
if msg.name() == "NAV_SOL":
msg.unpack()
self.satellites = msg.numSV
self.fix_status = msg.gpsFix
elif msg.name() == "NAV_POSLLH":
msg.unpack()
self.latitude = msg.Latitude * 1e-7
self.longitude = msg.Longitude * 1e-7
self.altitude = msg.hMSL / 1000.0
if self.altitude &lt; 0.0:
self.altitude = 0.0
except Exception as e:
logging.error("Unable to read from GPS Chip - %s" % str(e), exc_info=True)
self.healthy = False
def close(self):
logging.info("Closing GPS Module object")
self.healthy = False
self.gps.close()
self.gps = None
</code></pre>
<!--kg-card-end: markdown--><p>The python class has been tested for various scenarios for many days continuously. Even the model switching works fine realtime and does not need reset. Please feel free to modify or improve the class for your use case. The entire project source is available at <a href="https://github.com/codetiger/rpi-hab">my github project</a>.</p>]]></content:encoded></item><item><title><![CDATA[Sending large data like images over Lora]]></title><description><![CDATA[<p>Got obsessed with the Lora module E32-868T30D after playing with it for couple of months now. To be honest, this seemed to me like a life saver for hobbyists to start on RF. My previous attempts failed with I had to add RF to my projects. This time it was</p>]]></description><link>https://codetiger.github.io/blog/sending-large-data-like-images-over-lora/</link><guid ispermalink=false>61ae025522d8ff0cb289420a</guid><category><![CDATA[lora]]></category><category><![CDATA[raspberry pi]]></category><category><![CDATA[electronics]]></category><dc:creator><![CDATA[Harishankar]]></dc:creator><pubdate>Mon, 06 Dec 2021 13:13:23 GMT</pubdate><content:encoded><![CDATA[<p>Got obsessed with the Lora module E32-868T30D after playing with it for couple of months now. To be honest, this seemed to me like a life saver for hobbyists to start on RF. My previous attempts failed with I had to add RF to my projects. This time it was mostly a plug and play with simple configurations. </p><h3 id="speed">Speed: </h3><p>I read everywhere saying Lora is for smaller data packets and are not meant for larger data like images. There were some calculations showing Lora would take hours or days to transfer a single image. These are not fully true and are mostly limited to certain providers. In my project I needed a P2P data transfer and it worked just fine. </p><p>Initially I started with transfering 40 bytes of sensor data every 5 seconds which worked just fine. After analysing the logs, I found that the Chip completes the air transmission in few milliseconds and just waits for more data. So I decided to push more data by breaking an image into chunks and rebuilding it on the receiver size. </p><p>An image of size 38KB takes me around 5 mins to transfer with enough delay inbetween to avoid the buffer overflows. There is no easy way to calculate the exact delay needed for each chunk to get transfered, or depending on AUX alone as well did not help my case much. So I've implemented a hybrid aproach that worked for me.</p><figure class="kg-card kg-image-card"><img src="./..//content/images/2021/12/latest-7.jpg" class="kg-image" alt loading="lazy" width="640" height="360" srcset="https://codetiger.github.io/blog/content/images/size/w600/2021/12/latest-7.jpg 600w, https://codetiger.github.io/blog/content/images/2021/12/latest-7.jpg 640w"></figure><h3 id="acknowledgement">Acknowledgement:</h3><p>In my implementation, the Lora class accepts file size of upto few megabytes and internally splits and sends it in chunks. The sender ensures if the chunk was received successfully by marking the chunk after getting an acknowledgement. The reason why AUX alone didn't work for me was, both the transceivers had to send and receive messages and the module didn't support duplex transmission. So a predefined interval of delay helped in my case. Otherwise, the 38KB image can be transferred in less than a minute. </p><h3 id="implementation">Implementation:</h3><p>The source code is available in my <a href="https://github.com/codetiger/rpi-hab/blob/main/lora.py">Github project</a>. The Lora class uses SQLite for keeping track of chunks and acknowledgements. This class is the same as explained in my previous post where I've explained the basics <a href="https://codetiger.github.io/blog/transfer-images-over-lora-e32-module/">integrating E32-868T30D with Raspberry Pi</a></p><p>Using this implementation, I've run the project for couple days in a row and there was no issue in buffer overflow. So this code is tested well but feel free to improve if you can find issues. </p>]]></content:encoded></item><item><title><![CDATA[Connecting Lora E32 module with Raspberry Pi]]></title><description><![CDATA[Article explaining how to connect Lora E32 module to Raspberry Pi device and python code to send data between 2 modules using Lora communication.]]></description><link>https://codetiger.github.io/blog/transfer-images-over-lora-e32-module/</link><guid ispermalink=false>61a70abceadfe9c170a33c37</guid><category><![CDATA[lora]]></category><category><![CDATA[raspberry pi]]></category><category><![CDATA[electronics]]></category><dc:creator><![CDATA[Harishankar]]></dc:creator><pubdate>Wed, 01 Dec 2021 09:42:26 GMT</pubdate><content:encoded><![CDATA[<p>Recently, I've been reading about Lora and how RF industry has changed in the last 5 years. Especially for electronics hobbyists like me who are self taught and have very limited knowledge in RF communication domain, these new Lora modules have made life easier. There is no introduction needed for these modules as the entire community is talking about, so I straightaway jump into the subject. </p><p>For my recent hobby project (shall be explained in future posts), I need a long range communications module between 2 Raspberry Pi based devices. The approximate distance is roughly 30 kms within line of sight. The 30kms and line of sight should be enough to guess what am planning to do. However, I'll still keep that for another post. The easiest way to achieve long range communication today without the need for licenses, is using a Lora module. As it already supports ISM band and modules are already available for various bands depending on the country. </p><h3 id="regulations">Regulations:</h3><p>In India, the ISM band range of frequency 865 - 867 MHz is delicensed and allocated for general purpose use. The regulatory documents say, we are allowed to use a max of 1w transmission power within this range. The standard Lora modules are pre-configured for various global ISM bands like 433MHz, 868MHz and 915MHz. Now, if you notice, none of these frequencies are within the ISM band in India. Closest is 868MHz however, it is outside of the specified range. </p><p>Thanks to the operating frequency range of the Lora modules, each model supports a range of frequencies meant to support a range of channels. The device I chose for my project is E32-868T30D which supports frequency range from 862 MHz to 893 MHz. I was bit confused as the regulations did not explicitly mention whether the 865 and 867 frequencies are inclusive in the allowed range. So just to be on the safer side, I configured by devices to communicate in 866 MHz which is well within the range.</p><h3 id="lora-e32-868t30d">Lora E32-868T30D:</h3><p>In fact, I did a lot of research on various modules and finally chose this device just &#160;because of the 1w transmission power support. The actual advantage of this device comes from the support for UART communication. You can plug 2 devices into a computer with USB-UART adaptors and start &#160;configuring and testing the device. I started using CoolTerm app on my Mac for debugging and understanding the behaviour of this device. The manufacturer EByte has give a beautiful <a href="https://www.ebyte.com/en/pdf-down.aspx?id=672">documentation</a> for this module. It actually didn't help me much in the beginning while I was trying to understand the behaviour of the device. Later once you get the hang of it, the document comes handy as reference. </p><p>The device has M0 and M1 pins for configuring operating modes (Normal, Wake-up, Power svaing and sleep). Many articles say, there pins can be ignored, but neirhter ignoring nor connecting directly to ground worked for me. Only thing that worked for me is connecting them to GPIO pins (17 and 27) and programatically setting the high or low for different modes. To configure the settings using commands, you need to first set the device to Sleep mode. Then in normal mode, the device uses the persisted config. So I decided to use the GPIO pins to configure on program startup so even if I swap the devices, the new settings will take effect. </p><p>Note: You can configure and persist the setting once using a computer, and then use the UART to just send data directly. This also did work as expected. </p><p>The device has another AUX pin which becomes very important when sending large data continuously. For sending data at an interval greater than the transmission time (usually a few 10 milliseconds), you don't need to worry about this pin. The pin tells us if the data written previously is being ready by the internal transmitter module. So you need to wait until the pin signals you that it is ready for more data. </p><h3 id="connecting-to-raspberry-pi">Connecting to Raspberry Pi:</h3><p>For my project, I chose Raspberry Pi Zero W for various obvious reasons. They are small enough and computers running Linux rather than MCUs. Below wiring diagram explains the overall connections used. </p><figure class="kg-card kg-image-card"><img src="./..//content/images/2021/12/lora-E32-868T30D-2.png" class="kg-image" alt loading="lazy" width="720" height="405" srcset="https://codetiger.github.io/blog/content/images/size/w600/2021/12/lora-E32-868T30D-2.png 600w, https://codetiger.github.io/blog/content/images/2021/12/lora-E32-868T30D-2.png 720w" sizes="(min-width: 720px) 720px"></figure><p>Remember to connect the Tx pin of RPi to Rx pin of Lora module and the Rx pin of RPi to Tx pin of Lora module. For most people this sounds obvious but I initially had lot of doubts on the Lora module pin naming.</p><h3 id="source-code">Source code:</h3><p>The entire source code is available as part of my <a href="https://github.com/codetiger/rpi-hab/blob/main/lora.py">Gihub project</a>. Below is the reusable Lora Class in Python.</p><!--kg-card-begin: markdown--><pre><code class="language-python">#!/usr/bin/env python3
import serial
import logging, time
from datetime import datetime
import sqlite3
from struct import *
from threading import Thread
import RPi.GPIO as GPIO
AUX_PIN = 18
M0_PIN = 17
M1_PIN = 27
MODE_NORMAL = 0
MODE_WAKEUP = 1
MODE_POWER_SAVING = 2
MODE_SLEEP = 3
MAX_PACKET_SIZE = 58
class LoraModule(Thread):
ser = None
dbConn = None
delayAfterTransmit = 1.5
lastTransmitTime = None
addressHigh = 0x0
addressLow = 0x0
port = ""
healthy = True
def __init__(self, port="/dev/serial0", addressHigh=0xbc, addressLow=0x01, dataTimer=True, delay=1.5):
logging.getLogger("HABControl")
logging.info('Initialising Lora Module')
GPIO.setmode(GPIO.BCM)
GPIO.setup(AUX_PIN, GPIO.IN)
GPIO.setup(M0_PIN, GPIO.OUT)
GPIO.setup(M1_PIN, GPIO.OUT)
self.delayAfterTransmit = delay
self.lastTransmitTime = datetime.now()
self.addressHigh = addressHigh
self.addressLow = addressLow
self.port = port
self.setupPort()
if dataTimer:
self.dbConn = sqlite3.connect('data.db', detect_types=sqlite3.PARSE_DECLTYPES, check_same_thread=False)
self.dbConn.execute("CREATE TABLE IF NOT EXISTS habdata(id INTEGER PRIMARY KEY, data BLOB NOT NULL, chunked INT DEFAULT 0 NOT NULL, created timestamp NOT NULL, ack INT DEFAULT 0 NOT NULL, lasttry timestamp NOT NULL);")
Thread.__init__(self)
self.healthy = True
self.start()
def setupPort(self):
self.setMode(MODE_SLEEP)
try:
self.ser = serial.Serial(self.port, 9600, timeout=1, bytesize=serial.EIGHTBITS, parity=serial.PARITY_NONE, stopbits=serial.STOPBITS_ONE)
except Exception as e:
logging.error("Could not Open Lora Port - %s" % str(e))
self.ser = None
self.resetLoraModule(False)
self.ser.baudrate = 115200
def resetLoraModule(self, hard=False):
self.setMode(MODE_SLEEP)
time.sleep(0.2)
if hard:
packet = bytes([0xc4, 0xc4, 0xc4])
logging.info("Reset Lora Module Data: %s" % (packet.hex()))
self.ser.write(packet)
time.sleep(0.2)
packet = bytes([0xc0, self.addressHigh, self.addressLow, 0x3d, 0x04, 0xc4])
logging.info("Sending Config Packet Size: %d Data: %s" % (len(packet), packet.hex()))
self.ser.write(packet)
time.sleep(0.1)
res = self.waitForData(6)
if res is not None:
logging.info("Config confirmation: %s" % (res.hex()))
else:
logging.info("Config confirmation timeout")
time.sleep(0.1)
self.setMode(MODE_NORMAL)
time.sleep(0.1)
def setMode(self, mode):
if mode == MODE_NORMAL:
logging.info("Setting Lora for Normal Mode")
GPIO.output(M0_PIN, GPIO.LOW)
GPIO.output(M1_PIN, GPIO.LOW)
elif mode == MODE_WAKEUP:
logging.info("Setting Lora for Wakeup Mode")
GPIO.output(M0_PIN, GPIO.HIGH)
GPIO.output(M1_PIN, GPIO.LOW)
elif mode == MODE_POWER_SAVING:
logging.info("Setting Lora for Power Saving Mode")
GPIO.output(M0_PIN, GPIO.LOW)
GPIO.output(M1_PIN, GPIO.HIGH)
elif mode == MODE_SLEEP:
logging.info("Setting Lora for Sleep Mode")
GPIO.output(M0_PIN, GPIO.HIGH)
GPIO.output(M1_PIN, GPIO.HIGH)
def run(self):
while self.healthy:
duration = datetime.now() - self.lastTransmitTime
secondsFromLastTransmit = duration.total_seconds()
while not GPIO.input(AUX_PIN):
time.sleep(0.025)
duration = datetime.now() - self.lastTransmitTime
secondsFromLastTransmit = duration.total_seconds()
if secondsFromLastTransmit > 25:
self.healthy = False
time.sleep(0.025)
try:
if self.ser.in_waiting > 0:
self.recieveThread()
elif secondsFromLastTransmit > self.delayAfterTransmit:
self.transmitThread()
except Exception as e:
logging.error("Error in Lora module - %s" % str(e), exc_info=True)
self.healthy = False
def transmit(self, data):
try:
logging.info("Sending Packet Size: %d Data: %s" % (len(data), data.hex()))
self.ser.write(data)
self.ser.flush()
self.lastTransmitTime = datetime.now()
except Exception as e:
logging.error("Could not send data to Lora Port - %s" % str(e), exc_info=True)
self.healthy = False
def transmitThread(self):
try:
packet = bytearray()
packet.append(0xbc)
packet.append(0x02)
packet.append(0x04)
rows = self.dbConn.execute("SELECT * FROM habdata WHERE ack = 0 and lasttry &lt; Datetime('now', '-10 seconds') ORDER BY chunked ASC, created DESC LIMIT 5").fetchall()
for row in rows:
if len(packet) + len(row[1]) &lt;= MAX_PACKET_SIZE:
packet.append(0xda)
packet.append((int(row[0]) & 0xff00) >> 8) # higher byte of id
packet.append(int(row[0]) & 0xff) # lower byte of id
size = int(len(row[1])) & 0xff
size *= (-1 if row[2] else 1)
size = size.to_bytes(1, byteorder='big', signed=True)[0]
packet.append(size) # size of data
packet.extend(row[1]) # data
self.dbConn.execute("UPDATE habdata SET lasttry = datetime('now') WHERE id = ?", [row[0]])
else:
break
if len(packet) > 3:
self.transmit(packet)
except Exception as e:
logging.error("Could not send data to Lora - %s" % str(e), exc_info=True)
self.healthy = False
def waitForData(self, length, timeout=10):
callTime = datetime.now()
while self.ser.in_waiting &lt; length:
time.sleep(0.025)
duration = datetime.now() - callTime
secondsFromCallTime = duration.total_seconds()
if secondsFromCallTime > timeout:
return None
data = self.ser.read(length)
return data
def recieveThread(self):
if self.ser.in_waiting >= 3:
try:
data = self.ser.read(3)
if len(data) == 3 and data[0] == 0xac:
high = int(data[1])
low = int(data[2])
dataid = (high &lt;&lt; 8) | low
logging.info("Recieved ACK for %d" % (dataid))
self.dbConn.execute("UPDATE habdata SET ack = 1 WHERE id = ?", [dataid])
except Exception as e:
logging.error("Could not update ack to SQLite - %s" % str(e), exc_info=True)
def sendData(self, data):
CHUNK_SIZE = MAX_PACKET_SIZE - 8 # CallSign (1 byte) Dataid (2 bytes), Size (1 byte), Chunk index (2 byte), Total Chunks (2 byte)
try:
isChunked = len(data) > CHUNK_SIZE
totalChunks = int(len(data) / CHUNK_SIZE) + 1
if totalChunks > 255 * 255:
logging.error("Unable to send file, check file size")
return
if isChunked:
logging.debug("Data: Chunked %d, totalChunks %d" % (isChunked, totalChunks))
for i in range(0, totalChunks):
dt = data[i*CHUNK_SIZE:(i+1)*CHUNK_SIZE]
packet = bytearray()
indexBytes = i.to_bytes(2, byteorder='big', signed=False)
packet.append(indexBytes[0])
packet.append(indexBytes[1])
totalChunksBytes = totalChunks.to_bytes(2, byteorder='big', signed=False)
packet.append(totalChunksBytes[0])
packet.append(totalChunksBytes[1])
packet.extend(dt)
logging.debug("Data added to Queue: %s", packet.hex())
self.dbConn.execute("INSERT INTO habdata(data, chunked, created, lasttry) VALUES (?, 1, datetime('now'), datetime('now'));", [sqlite3.Binary(packet)])
else:
logging.debug("Data added to Queue: %s", data.hex())
self.dbConn.execute("INSERT INTO habdata(data, created, lasttry) VALUES (?, datetime('now'), datetime('now'));", [sqlite3.Binary(data)])
except Exception as e:
logging.error("Could not insert to SQLite - %s" % str(e), exc_info=True)
def hasChunkData(self):
try:
row = self.dbConn.execute("SELECT COUNT(*) FROM habdata WHERE ack = 0 and chunked = 1").fetchone()
if row and row[0] > 0:
logging.debug("Chunk pending transmit: %d" % (row[0]))
return True
else:
self.dbConn.execute("DELETE FROM habdata WHERE ack = 1 and chunked = 1")
return False
except Exception as e:
logging.error("Could not read from SQLite - %s" % str(e), exc_info=True)
return False
def close(self):
logging.info("Closing Lora Module object")
self.healthy = False
self.ser.close()
self.ser = None
self.dbConn.close()
self.dbConn = None
GPIO.cleanup()
</code></pre>
<!--kg-card-end: markdown--><p>Feel free to remove need for SQLite DB usage if not needed. The DB approach was introduced for sending large data and waiting for acknoledgement. This shall be covered in detail in another post. </p>]]></content:encoded></item><item><title><![CDATA[Why blog (again)?]]></title><description><![CDATA[<p>Tried a few times before and gave up on blogging each time! Even micro blogging didn't work well for me. After all the failure attempts, this time trying something different to see if I can do it. </p><blockquote>Failure does not mean the end, at least until you fail</blockquote>]]></description><link>https://codetiger.github.io/blog/why-blog/</link><guid ispermalink=false>61a1add4eadfe9c170a33bd6</guid><dc:creator><![CDATA[Harishankar]]></dc:creator><pubdate>Sat, 27 Nov 2021 04:39:23 GMT</pubdate><content:encoded><![CDATA[<p>Tried a few times before and gave up on blogging each time! Even micro blogging didn't work well for me. After all the failure attempts, this time trying something different to see if I can do it. </p><blockquote>Failure does not mean the end, at least until you fail to use the try again option!</blockquote><h3 id="goal">Goal</h3><ul><li>Keep a log of the hobby projects for future reference and memories</li><li>Try something that I always thought I am not good at</li><li>Assuming writing helps me keep focus on things! Prove it!</li><li>Consume less and produce more! (Keep away from mindless endless scrolling and start being productive)</li><li>Post random topics and pictures like this one</li></ul><figure class="kg-card kg-image-card kg-card-hascaption"><img src="./..//content/images/2021/11/F7658991-1E23-47CE-B9F3-277295F76502_1_105_c.jpeg" class="kg-image" alt loading="lazy" width="962" height="826" srcset="https://codetiger.github.io/blog/content/images/size/w600/2021/11/F7658991-1E23-47CE-B9F3-277295F76502_1_105_c.jpeg 600w, https://codetiger.github.io/blog/content/images/2021/11/F7658991-1E23-47CE-B9F3-277295F76502_1_105_c.jpeg 962w" sizes="(min-width: 720px) 720px"><figcaption>Small world - Live and let live</figcaption></figure>]]></content:encoded></item></channel></rss>